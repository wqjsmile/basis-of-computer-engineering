### 1. 树的概念

在计算器科学中，树（英语：tree）是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

  ①每个结点有零个或多个子结点；
  ②没有父结点的结点称为根结点；
  ③每一个非根结点有且只有一个父结点；
  ④除了根结点外，每个子结点可以分为多个不相交的子树；

![img](https://i.loli.net/2021/06/16/qhd2XRgLlIVj9kf.png)

### 2. 树的常用概念

#### 2.1 度

树的结点包含一个数据和多个指向子树的分支结点拥有的子树的数量为结点的度，度为0的结点是叶结点，度不为0的结点为分支结点，树的度定义为树的所有结点中度的最大值。

![img](https://i.loli.net/2021/06/16/yxTMtS1PC5kdW3h.png)

#### 2.2树的前驱和后继

结点的直接后继称为结点的孩子，结点称为孩子的双亲。
结点的孩子的孩子称为结点的孙子，结点称为子孙的祖先。
同一个双亲的孩子之间互称兄弟。

![img](https://i.loli.net/2021/06/16/lkpKBHZ7wxus8tc.png)

#### 2.3 树的层次

![img](https://i.loli.net/2021/06/16/kUxAcnaWMyjR25F.png)

树中根结点为第1层，根结点的孩子为第2层，依次类推。
树中结点的最大层次称为树的深度或高度。

#### 2.4 树的有序性

![img](https://i.loli.net/2021/06/16/BEZCekMOalJXpVo.png)

如果树中结点的各子树从左向右是有序的，子树间不能互换位置，则称该树为有序树，否则为无序树。

#### 2.5 森林

森林是由n棵互不相交的树组成的集合。
三棵树组成的森林如下：

![img](https://i.loli.net/2021/06/16/6I9ufiy1Rljw7t3.png)

### 3. 树的分类(主要总结二叉树)

二叉树：每个节点最多含有两个子树的树称为二叉树。

#### 3.1 二叉树的定义

二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2i-1个结点；深度为k的二叉树至多有2k-1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。

![img](https://i.loli.net/2021/06/16/nLEzhPX7vZwJQ5s.jpg)

#### 3.2 二叉树的分类

##### (1) 满二叉树

满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。

![img](https://upload-images.jianshu.io/upload_images/4630295-e8794f687ebce60f.png?imageMogr2/auto-orient/strip|imageView2/2/w/316/format/webp)

满二叉树的性质：

- 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;
- 叶子数为$2^h$;
- 第k层的结点数是：$2^{k-1}$;
- 总结点数是：$2^{k}-1$，且总节点数一定是奇数。

##### (2) 完全二叉树

完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。

**注：**完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。

![img](https://i.loli.net/2021/06/16/7EmQKuYclzkjX8R.png)

##### (3) 完满二叉树

![img](https://i.loli.net/2021/06/16/gMoib4kc6WdJYG7.png)

完满二叉树：除叶子结点之外的每个结点都有两个子结点。

![img](https://upload-images.jianshu.io/upload_images/4630295-96ab0ed90baf906e.png?imageMogr2/auto-orient/strip|imageView2/2/w/743/format/webp)



#### 3.3 二叉树的遍历

- 先序遍历(前序遍历)：根--左--右
- 中序遍历：左--根--右
- 后序遍历：左--右--根

#### 3.4 常见二叉树

##### (1) 二叉查找树

**二叉查找树定义**：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

- 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
- 左、右子树也分别为二叉排序树；
- 没有键值相等的结点。

二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。

二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。

二叉查找树的高度决定了二叉查找树的查找效率。

**二叉查找树的插入过程如下：**

```
1) 若当前的二叉查找树为空，则插入的元素为根节点;
2) 若插入的元素值小于根节点值，则将元素插入到左子树中;
3) 若插入的元素值不小于根节点值，则将元素插入到右子树中。　　
```

##### (2) 二叉平衡树

我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为log2n，其各操作的时间复杂度O(log2n)同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。于是就有了我们下边介绍的平衡二叉树。

**平衡二叉树定义：**平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。

```
最小二叉平衡树的节点的公式如下：
　　F(n)=F(n-1)+F(n-2)+1
　　这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。
```

###### AVL树

在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。**这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。**

**AVL树的自平衡操作——旋转：**

AVL树最关键的也是最难的一步操作就是**旋转**。旋转主要是为了实现AVL树在实施了插入和删除操作以后，树重新回到平衡的方法。下面我们重点研究一下AVL树的旋转。

　　对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况：

![img](https://i.loli.net/2021/06/16/PwibuenT7MatNWG.jpg)

​       1) 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。

　　2) 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。

　　3) 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。

　　4) 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。

　　从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。

![img](https://i.loli.net/2021/06/16/EcizIRHd8YmWwsx.jpg)

**单旋转**是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。

为使树恢复平衡，我们把k1变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。

这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。

**双旋转**

对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。

![img](https://i.loli.net/2021/06/16/eD5GUbHfjnLFWN8.jpg)

![左旋](https://i.loli.net/2021/06/16/nDzrICkRuxBysaF.gif)

![](https://i.loli.net/2021/06/16/qImAlXb1M7CG6wK.gif)

```
左旋——自己变为右孩子的左孩子； 右旋——自己变为左孩子的右孩子；
```

为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树。

###### 红黑树

**红黑树的定义：**红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，称之为"对称二叉B树"，它现代的名字是在 Leo J. Guibas 和 Robert Sedgewick 于1978年写的一篇论文中获得的。**它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。**

红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如实时应用（real time application）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。此外，红黑树还是2-3-4树的一种等同，它们的思想是一样的，只不过红黑树是2-3-4树用二叉树的形式表示的。

**红黑树的性质：**

红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:

```
性质1. 节点是红色或黑色。
性质2. 根是黑色。
性质3. 所有叶子都是黑色（叶子是NIL节点）。
性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子  到根的所有路径上不能有两个连续的红色节点。)
性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
```

![An example of a red-black tree](https://i.loli.net/2021/06/16/68rbUuEJ9QaBMem.png)　　

这些约束确保了红黑树的关键特性: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。

**红黑树的自平衡操作：**

　　因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量(O(logn))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为O(logn) 次。

　　**我们首先以二叉查找树的方法增加节点并标记它为红色。如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的（违背性质5）。**但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。下面要进行什么操作取决于其他临近节点的颜色。同人类的家族树中一样，我们将使用术语叔父节点来指一个节点的父节点的兄弟节点。注意:

- 性质1和性质3总是保持着。
- 性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。
- 性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。

**为什么要有红黑树？**

大多数二叉排序树BST的操作（查找、最大值、最小值、插入、删除等等）都是 ![[公式]](https://www.zhihu.com/equation?tex=O(h)) 的时间复杂度，h 为树的高度。但是对于斜树而言（BST极端情况下出现），BST的这些操作的时间复杂度将达到  ![[公式]](https://www.zhihu.com/equation?tex=O(n)) 。为了保证BST的所有操作的时间复杂度的上限为  ![[公式]](https://www.zhihu.com/equation?tex=O(logn)) ，就要想办法把一颗BST树的高度一直维持在![[公式]](https://www.zhihu.com/equation?tex=logn)，而红黑树就做到了这一点，红黑树的高度始终都维持在![[公式]](https://www.zhihu.com/equation?tex=logn)，n 为树中的顶点数目。

**红黑树RBT与平衡二叉树AVL比较：**

AVL 树比红黑树更加平衡，但AVL树在插入和删除的时候也会存在大量的旋转操作。所以当你的应用涉及到频繁的插入和删除操作，切记放弃AVL树，选择性能更好的红黑树；当然，如果你的应用中涉及的插入和删除操作并不频繁，而是查找操作相对更频繁，那么就优先选择 AVL 树进行实现。

**红黑树RBT为什么可以保持平衡？**

![image-20210616200333425](https://i.loli.net/2021/06/16/fOcW3p8YAtUhiCo.png)

红黑树的应用？

1. 大多数自平衡BST(self-balancing BST) 库函数都是用红黑树实现的，比如C++中的map 和 set （或者 Java 中的 TreeSet 和 TreeMap）。
2. 红黑树也用于实现 Linux 操作系统的 CPU 调度。完全公平调度（Completely Fair Scheduler）使用的就是红黑树。

##### (3) 哈夫曼树

Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。

**定义**：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。 这个定义里面涉及到了几个陌生的概念，下面就是一颗哈夫曼树，我们来看图解答。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/01.jpg?raw=true)

- 路径和路径长度

  **定义**：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。
  **例子**：100和80的路径长度是1，50和30的路径长度是2，20和10的路径长度是3。

- 结点的权及带权路径长度

  **定义**：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。
  **例子**：节点20的路径长度是3，它的带权路径长度= 路径长度 * 权 = 3 * 20 = 60。

- 树的带权路径长度

  **定义**：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。
  **例子**：示例中，树的WPL= 1\*100 + 2\*50 + 3\*20 + 3\*10 = 100 + 160 + 60 + 30 = 290。

**哈夫曼树如何构造？**

假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，哈夫曼树的构造规则为：

```
1. 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；
2. 在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
3. 从森林中删除选取的两棵树，并将新树加入森林；
4. 重复(02)、(03)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。
```

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/03.jpg?raw=true)

**哈夫曼树有什么作用？**

在计算机数据处理中，哈夫曼编码使用变长编码表变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。



#### 3.5 B树

##### (1) B树

B树也是一种用于查找的平衡树，但是它不是二叉树。

**B树的定义：**B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。

特点：

```
1.定义任意非叶子结点最多只有M个儿子；且M>2
2.根结点的儿子数为[2, M]
3.除根结点以外的非叶子结点的儿子数为[M/2, M]
4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
5.非叶子结点的关键字个数=指向儿子的指针个数-1
6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]
7.非叶子结点的指针：P[1], P[2], …, P[M]，其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树
8.所有叶子结点位于同一层
```

![img](https://upload-images.jianshu.io/upload_images/4630295-be637e44f62bd8dd.png?imageMogr2/auto-orient/strip|imageView2/2/w/622/format/webp)

**插入与平衡过程**

这个图用以表示往 4 阶 B 树中依次插入下面这组数据的过程：

```
6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4
```

![img](https://i.loli.net/2021/06/16/OvSd2aRnY1Coshx.gif)

**4 阶 B 树表示每个节点最多有 4 个子树、3 个关键字，最少有 2 个子树、一个关键字**

**添加/删除也是一样的，要考虑添加/删除孩子后，父节点是否还满足子树 `k` 介于 `M/2` 和 `M` 的条件，不满足就得从别的节点拆子树甚至修改相关子树结构来保持平衡。**

##### (2) B+树

B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

**B+的特性：
 1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的
 2.不可能在非叶子结点命中
 3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
 4.更适合文件索引系统**
 **原因： 增删文件（节点）时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率**

![img](https://upload-images.jianshu.io/upload_images/4630295-486680e4ce7ef709.png?imageMogr2/auto-orient/strip|imageView2/2/w/582/format/webp)

B+**数插入和平衡**

![img](https://i.loli.net/2021/06/16/qHKeUW9fpbtjr5R.gif)

使用场景：

**文件系统和数据库系统中常用的B/B+ 树，他通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。他广泛用于文件系统及数据库中，如：
 Windows：HPFS 文件系统
 Mac：HFS，HFS+ 文件系统
 Linux：ResiserFS，XFS，Ext3FS，JFS 文件系统
 数据库：ORACLE，MYSQL，SQLSERVER 等中**

**B树：有序数组+平衡多叉树
 B+树：有序数组链表+平衡多叉树**

##### (3) B*树

B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。

B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；

B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；

所以，B*树分配新结点的概率比B+树要低，空间使用率更高。

![img](https://i.loli.net/2021/06/16/RlO5DrL9nE7akpS.jpg)

##### B树、B+树、B*树的比较：

(1) B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;

(2) B+树和B树的区别

（1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；
（2）B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；
（3）**B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。**
（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;

- 特点：
- 1、B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；
- 2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
- 3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
- 4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
- B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。

(3) B* 数和B数的区别

（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b*树的初始化个数为（cei(2/3*m)）

（2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；

- 特点
  在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；

#### 3.6 R树

B树是一棵平衡树，它是把一维直线分为若干段线段，当我们查找满足某个要求的点的时候，只要去查找它所属的线段即可。这种思想其实是先找到一个大的空间，再逐步缩小所要查找的空间，最终在一个自己设定的最小不可分空间内找出满足要求的解。

R树恰恰也用到了这样的思想。R树是B树的扩展，它作为最流行的空间索引结构，广泛地应用于各种数据库系统。

R树很好地解决了这种高维空间搜索问题。它把B树的思想扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来存储高维数据的平衡树。

举个例子：

传统的方法需要先找出math成绩在[80,90]的学生，再从中找出chems成绩再[80,90]的学生。许多学生并不符合第二个条件，但却由于符合第一个条件二被选出，影响了查询效率。R树解决了这类高维搜索问题，大大提高了数据库查询效率。

如上所述，R树是B树在高维空间的扩展，是一棵平衡树。每个R树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中。根据R树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可。

![一棵典型的R树](https://i.loli.net/2021/06/16/IXC6mtfvhwUA3Ve.jpg)

一棵R树满足如下的性质：
1. 除非它是根结点之外，所有叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。
2. 对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。
3. 每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。
4. 对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。
5. 所有叶子结点都位于同一层，因此R树为平衡树。

其中每个非叶结点表示了一个最小矩形，它包含了所有子树中的点。每个叶子结点则表示一个点。
![这里写图片描述](https://i.loli.net/2021/06/16/XECmDiWy7AoeIJa.jpg)

如上图，如果要查询 x属于[5,8.5] y属于[4,7.5]的点，可以在对应的坐标图上画出查询区域。只需根据R树中对应区块与查询区域重合部分即可逐层确认查询结果的点。





> [数据结构（十三）——树_生命不息，奋斗不止的技术博客_51CTO博客](https://blog.51cto.com/u_9291927/2068745)

> [数据结构之树_lishinho的博客-CSDN博客_数据结构树](https://blog.csdn.net/wannuoge4766/article/details/83998377)

> [[Data Structure\] 数据结构中各种树 - Poll的笔记 - 博客园 (cnblogs.com)](https://www.cnblogs.com/maybe2030/p/4732377.html)

> [什么是红黑树，一篇文章解决所有疑惑~~ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143585797)

> [彻底搞懂系列B-树、B+树、B-树、B*树_chai471793的博客-CSDN博客_b+树](https://blog.csdn.net/chai471793/article/details/99563704)

> http://www.cnblogs.com/skywang12345/

> [R树简介_u012436758的博客-CSDN博客_r树](https://blog.csdn.net/u012436758/article/details/54586469)

